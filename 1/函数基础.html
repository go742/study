<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
    <script>
        /*
        * 函数
        * function 函数名(参数名1...){
        *    语句块
        * }
        *函数也是对象
        * */
        function createTable(){

        }
        createTable();



        /*
        * var fn1 = function(){} 匿名函数 将匿名函数赋值给变量，执行变量函数就是执行
        * 这个匿名函数，匿名函数不能再定义该函数之前执行调用
        *
        * function fn2(){} 普通函数 可以在定义之前调用函数执行
        *
        * js是解释性语言，在当前script标签代码执行的开始阶段，就会将普通函数放入在堆中，只是放入在堆中
        * 但是函数中的内容变并没有解析执行，每进行一次函数执行就会解析一次
        *
        *
        * */
        //fn1();
        fn2();
        var fn1 = function (){
            console.log("aaa");
        }
        function fn2(){
            console.log("bbb");
        }


        /*
        *重名的危险
        * 1.普通函数和匿名函数重名 匿名函数会覆盖普通函数，原因是普通函数在script
        * 标签开始时就将函数放入在堆中，而匿名函数是在代码解析的时候才存入堆中的，
        * 如果名称相同，就会覆盖原函数
        * 2.普通函数和变量重名 变量会覆盖普通函数
        * */

        /*var fn3 = function(){
            console.log("ddd");
        }*/
        var fn3 = 10;
        function fn3(){
            console.log("ccc");
        }
       // fn3();


        /*构造函数定义法
        * 构造函数定义函数
        * 使用全字符串，参数在最前面，后面的字符串内容是执行代码的语句
        * 缺点：代码会做2次执行，第一次会将函数中的字符串解析成普通代码，第二次执行该代码，
        * 因此效率极低
        * 优点：可以用任何语言传入该js代码并且执行
        * */
        var fn4 = new Function("a","console.log(a)");
        fn4(10);

        (function (){
            console.log("自执行函数");
            //只能执行一次，执行完成后再也找不到了，变成孤儿对象（有引用的，不可被回收）
        })();
    </script>
</body>
</html>